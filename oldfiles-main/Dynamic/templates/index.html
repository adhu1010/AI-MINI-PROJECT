<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Path Finding Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        #canvas {
            border: 1px solid black;
        }
        #controls {
            margin-top: 20px;
        }
        #controls button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
        }
    </style>
</head>
<body>
    <h1>Path Finding Visualization</h1>
    <canvas id="canvas" width="500" height="500"></canvas> <!-- 500x500 for a 10x10 grid with 50px cells -->
    <div id="controls">
        <button id="startButton">Start Path Finding</button>
        <button id="stopButton">Stop</button>
        <button id="restartButton">Restart</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 50;  // Size of each cell in pixels
        const rows = 10; // 10x10 grid
        const cols = 10;

        let staticObstacles = [{x: 3, y: 2}, {x: 4, y: 2}, {x: 5, y: 2}];
        let dynamicObstacles = [{x: 1, y: 5}, {x: 2, y: 6}];
        const start = {x: 0, y: 0};
        const goal = {x: 9, y: 9}; // Adjusted goal for a 10x10 grid
        let path = [];
        let current_position = {x: 0, y: 0};
        let interval;

        // Draw the grid
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * gridSize;
                    const y = row * gridSize;

                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, gridSize, gridSize);

                    // Color static obstacles
                    if (staticObstacles.some(obstacle => obstacle.x === col && obstacle.y === row)) {
                        ctx.fillStyle = 'gray';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    }

                    // Color dynamic obstacles
                    else if (dynamicObstacles.some(obstacle => obstacle.x === col && obstacle.y === row)) {
                        ctx.fillStyle = 'brown';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    }

                    // Color the start node
                    else if (start.x === col && start.y === row) {
                        ctx.fillStyle = 'green';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    }

                    // Color the goal node
                    else if (goal.x === col && goal.y === row) {
                        ctx.fillStyle = 'red';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    }

                    // Color the path
                    else if (path.some(step => step.x === col && step.y === row)) {
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    }

                    // Color the current position of the robot
                    else if (current_position.x === col && current_position.y === row) {
                        ctx.fillStyle = 'yellow';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    }
                }
            }
        }

        // Function to update dynamic obstacles
        async function updateObstacles(static_obstacles, dynamic_obstacles, robotPosition) {
            const newDynamicObstacles = [];

            dynamic_obstacles.forEach(obstacle => {
                let new_position;
                let valid_position_found = false;

                // Try to move the obstacle to a valid, unoccupied position
                while (!valid_position_found) {
                    // Generate a random direction: up, down, left, right
                    const direction = Math.floor(Math.random() * 4);
                    let delta = [0, 0];

                    if (direction === 0) delta = [-1, 0];  // Move up
                    if (direction === 1) delta = [1, 0];   // Move down
                    if (direction === 2) delta = [0, -1];  // Move left
                    if (direction === 3) delta = [0, 1];   // Move right

                    // Calculate the new position
                    new_position = {x: obstacle.x + delta[0], y: obstacle.y + delta[1]};

                    // Check if the new position is within grid bounds
                    if (
                        new_position.x >= 0 && new_position.x < cols &&
                        new_position.y >= 0 && new_position.y < rows &&
                        !static_obstacles.some(ob => ob.x === new_position.x && ob.y === new_position.y) &&  // Check static obstacles
                        !newDynamicObstacles.some(ob => ob.x === new_position.x && ob.y === new_position.y) &&  // Check other dynamic obstacles
                        (robotPosition.x !== new_position.x || robotPosition.y !== new_position.y)  // Check robot position
                    ) {
                        valid_position_found = true;
                    }
                }

                newDynamicObstacles.push(new_position);
            });

            return newDynamicObstacles;
        }

        // Main function for dynamic pathfinding
        function startPathfinding() {
            stopInterval();  // Stop any previous interval if active

            path = getPath(current_position, goal, staticObstacles, dynamicObstacles); // Get the initial path

            interval = setInterval(async function() {
                if (current_position.x === goal.x && current_position.y === goal.y) {
                    clearInterval(interval); // Stop when the robot reaches the goal
                    alert("Goal reached!");
                    document.getElementById('startButton').disabled = false;
                    document.getElementById('restartButton').disabled = false;
                    return;
                }

                // Move dynamic obstacles, ensuring no overlap
                dynamicObstacles = await updateObstacles(staticObstacles, dynamicObstacles, current_position);

                // Check if the next step in the path is blocked by a dynamic obstacle
                if (path.length > 0) {
                    const next_step = path[0]; // Next step in the current path

                    if (dynamicObstacles.some(obstacle => obstacle.x === next_step.x && obstacle.y === next_step.y)) {
                        // If blocked, re-plan the path
                        path = await getPath(current_position, goal, staticObstacles, dynamicObstacles);

                        // If no valid path, stop
                        if (!path || path.length === 0) {
                            clearInterval(interval);
                            alert("Path blocked, no valid path found!");
                            document.getElementById('startButton').disabled = false;
                            document.getElementById('restartButton').disabled = false;
                            return;
                        }
                    } else {
                        // If not blocked, move the robot to the next step
                        current_position = path.shift();
                    }
                }

                // Update the grid with new positions
                drawGrid();

            }, 1000); // Update every second
        }

        function stopInterval() {
            if (interval) {
                clearInterval(interval);
                interval = null; // Reset interval to null
                document.getElementById('startButton').disabled = false; // Enable start button
                document.getElementById('restartButton').disabled = false; // Enable restart button
            }
        }

        function restartPathfinding() {
            stopInterval(); // Stop any active pathfinding
            current_position = {x: 0, y: 0};
            path = [];
            dynamicObstacles = [{x: 1, y: 5}, {x: 2, y: 6}]; // Reset dynamic obstacles
            drawGrid();
        }

        function getPath(start, goal, static_obstacles, dynamic_obstacles) {
            const openSet = [];
            const closedSet = [];
            const cameFrom = {};
            const gScore = {};
            const fScore = {};

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    gScore[`${col},${row}`] = Infinity;
                    fScore[`${col},${row}`] = Infinity;
                }
            }

            gScore[`${start.x},${start.y}`] = 0;
            fScore[`${start.x},${start.y}`] = heuristic(start, goal);
            openSet.push(start);

            while (openSet.length > 0) {
                // Sort openSet by fScore
                openSet.sort((a, b) => fScore[`${a.x},${a.y}`] - fScore[`${b.x},${b.y}`]);
                const current = openSet.shift();

                // If we reached the goal
                if (current.x === goal.x && current.y === goal.y) {
                    return reconstructPath(cameFrom, current);
                }

                closedSet.push(current);

                // Get neighbors
                const neighbors = getNeighbors(current, static_obstacles, dynamic_obstacles);

                for (const neighbor of neighbors) {
                    if (closedSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
                        continue; // Ignore the neighbor which is already evaluated.
                    }

                    const tentative_gScore = gScore[`${current.x},${current.y}`] + 1;

                    if (!openSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
                        openSet.push(neighbor); // Discover a new node
                    } else if (tentative_gScore >= gScore[`${neighbor.x},${neighbor.y}`]) {
                        continue; // This is not a better path
                    }

                    // This path is the best until now. Record it!
                    cameFrom[`${neighbor.x},${neighbor.y}`] = current;
                    gScore[`${neighbor.x},${neighbor.y}`] = tentative_gScore;
                    fScore[`${neighbor.x},${neighbor.y}`] = gScore[`${neighbor.x},${neighbor.y}`] + heuristic(neighbor, goal);
                }
            }

            return []; // No valid path found
        }

        function heuristic(a, b) {
            // Manhattan distance
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function getNeighbors(position, static_obstacles, dynamic_obstacles) {
            const neighbors = [];

            const directions = [
                {x: -1, y: 0}, // Left
                {x: 1, y: 0},  // Right
                {x: 0, y: -1}, // Up
                {x: 0, y: 1}   // Down
            ];

            for (const dir of directions) {
                const neighbor = {x: position.x + dir.x, y: position.y + dir.y};

                // Check if neighbor is within bounds and not an obstacle
                if (
                    neighbor.x >= 0 && neighbor.x < cols &&
                    neighbor.y >= 0 && neighbor.y < rows &&
                    !static_obstacles.some(ob => ob.x === neighbor.x && ob.y === neighbor.y) &&
                    !dynamic_obstacles.some(ob => ob.x === neighbor.x && ob.y === neighbor.y)
                ) {
                    neighbors.push(neighbor);
                }
            }

            return neighbors;
        }

        function reconstructPath(cameFrom, current) {
            const total_path = [current];
            while (`${current.x},${current.y}` in cameFrom) {
                current = cameFrom[`${current.x},${current.y}`];
                total_path.push(current);
            }
            return total_path.reverse(); // Reverse the path to start from the beginning
        }

        // Event Listeners
        document.getElementById('startButton').addEventListener('click', function() {
            this.disabled = true;
            document.getElementById('restartButton').disabled = true;
            startPathfinding();
        });

        document.getElementById('stopButton').addEventListener('click', stopInterval);

        document.getElementById('restartButton').addEventListener('click', restartPathfinding);

        // Initial Draw
        drawGrid();
    </script>
</body>
</html>
