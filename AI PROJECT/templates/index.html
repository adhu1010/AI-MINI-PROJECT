<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Path Finding Visualization with A*</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        #canvas {
            border: 1px solid black;
        }
        #controls {
            margin-top: 20px;
        }
        #controls button, #controls label {
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
        }
    </style>
</head>
<body>
    <h1>Path Finding Visualization</h1>
    <canvas id="canvas" width="500" height="500"></canvas>

    <div id="controls">
        <button id="startButton">Start Path Finding</button>
        <button id="stopButton">Stop</button>
        <button id="restartButton">Restart</button>

        <div>
            <label for="obstacleType">Select Obstacle Type:</label>
            <select id="obstacleType">
                <option value="static">Static Obstacle</option>
                <option value="dynamic">Dynamic Obstacle</option>
            </select>
        </div>
        <button id="clearObstacles">Clear Obstacles</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 50;  // Size of each cell in pixels
        const rows = 10;
        const cols = 10;

        let staticObstacles = [];
        let dynamicObstacles = [];
        const start = {x: 0, y: 0};
        const goal = {x: 9, y: 9}; // Goal remains at (9,9)
        let path = [];
        let current_position = {x: 0, y: 0};
        let interval;
        let selectedObstacleType = 'static';

        // Draw the grid
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * gridSize;
                    const y = row * gridSize;

                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, gridSize, gridSize);

                    // Color static obstacles
                    if (staticObstacles.some(obstacle => obstacle.x === col && obstacle.y === row)) {
                        ctx.fillStyle = 'gray';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    }

                    // Color dynamic obstacles
                    else if (dynamicObstacles.some(obstacle => obstacle.x === col && obstacle.y === row)) {
                        ctx.fillStyle = 'brown';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    }

                    // Color the start node
                    else if (start.x === col && start.y === row) {
                        ctx.fillStyle = 'green';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    }

                    // Color the goal node
                    else if (goal.x === col && goal.y === row) {
                        ctx.fillStyle = 'red';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    }

                    // Color the path
                    else if (path.some(step => step.x === col && step.y === row)) {
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    }

                    // Color the current position of the robot
                    else if (current_position.x === col && current_position.y === row) {
                        ctx.fillStyle = 'yellow';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    }
                }
            }
        }

        // Function to add obstacle by clicking on the grid
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const col = Math.floor(x / gridSize);
            const row = Math.floor(y / gridSize);

            if (selectedObstacleType === 'static') {
                // Add or remove static obstacle
                const index = staticObstacles.findIndex(obstacle => obstacle.x === col && obstacle.y === row);
                if (index === -1 && !(col === start.x && row === start.y) && !(col === goal.x && row === goal.y)) {
                    staticObstacles.push({x: col, y: row});
                } else {
                    staticObstacles.splice(index, 1);
                }
            } else if (selectedObstacleType === 'dynamic') {
                // Add or remove dynamic obstacle
                const index = dynamicObstacles.findIndex(obstacle => obstacle.x === col && obstacle.y === row);
                if (index === -1 && !(col === start.x && row === start.y) && !(col === goal.x && row === goal.y)) {
                    dynamicObstacles.push({x: col, y: row});
                } else {
                    dynamicObstacles.splice(index, 1);
                }
            }

            drawGrid();
        });

        // A* pathfinding algorithm
        function getPath(start, goal, staticObstacles) {
            const openSet = [start];
            const closedSet = new Set();
            const cameFrom = {};
            const gScore = {};
            const fScore = {};

            gScore[`${start.x},${start.y}`] = 0;
            fScore[`${start.x},${start.y}`] = heuristic(start, goal);

            while (openSet.length > 0) {
                // Find the node in openSet with the lowest fScore
                const current = openSet.reduce((lowest, node) => {
                    return fScore[`${node.x},${node.y}`] < fScore[`${lowest.x},${lowest.y}`] ? node : lowest;
                });

                // Check if we reached the goal
                if (current.x === goal.x && current.y === goal.y) {
                    return reconstructPath(cameFrom, current);
                }

                // Move current node from openSet to closedSet
                openSet.splice(openSet.indexOf(current), 1);
                closedSet.add(`${current.x},${current.y}`);

                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    if (closedSet.has(`${neighbor.x},${neighbor.y}`) ||
                        staticObstacles.some(obstacle => obstacle.x === neighbor.x && obstacle.y === neighbor.y)) {
                        continue; // Ignore obstacles
                    }

                    const tentative_gScore = (gScore[`${current.x},${current.y}`] || Infinity) + 1;

                    // This path is the best until now. Record it!
                    if (!openSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) {
                        openSet.push(neighbor);
                    } else if (tentative_gScore >= (gScore[`${neighbor.x},${neighbor.y}`] || Infinity)) {
                        continue; // Not a better path
                    }

                    // This path is the best until now. Record it!
                    cameFrom[`${neighbor.x},${neighbor.y}`] = current;
                    gScore[`${neighbor.x},${neighbor.y}`] = tentative_gScore;
                    fScore[`${neighbor.x},${neighbor.y}`] = (gScore[`${neighbor.x},${neighbor.y}`] || Infinity) + heuristic(neighbor, goal);
                }
            }

            return []; // No path found
        }

        // Get the neighbors of a node
        function getNeighbors(node) {
            const neighbors = [];
            const directions = [
                {x: -1, y: 0}, // up
                {x: 1, y: 0},  // down
                {x: 0, y: -1}, // left
                {x: 0, y: 1}   // right
            ];

            for (const direction of directions) {
                const neighbor = {x: node.x + direction.x, y: node.y + direction.y};
                if (neighbor.x >= 0 && neighbor.x < cols && neighbor.y >= 0 && neighbor.y < rows) {
                    neighbors.push(neighbor);
                }
            }
            return neighbors;
        }

        // Heuristic function (Manhattan distance)
        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        // Reconstruct the path from the end node to the start node
        function reconstructPath(cameFrom, current) {
            const totalPath = [current];
            while (current in cameFrom) {
                current = cameFrom[current];
                totalPath.push(current);
            }
            return totalPath.reverse();
        }

        // Main function to start pathfinding
        function startPathfinding() {
            path = getPath(start, goal, staticObstacles);
            current_position = {x: 0, y: 0};
            if (path.length === 0) {
                alert("No path found!");
                return;
            }
            moveRobotAlongPath();
        }

        // Move the robot along the path
        function moveRobotAlongPath() {
            if (path.length === 0) {
                alert("No path found!");
                return;
            }

            interval = setInterval(() => {
                if (path.length > 0) {
                    current_position = path.shift();
                    drawGrid();

                    // Check if we reached the goal
                    if (current_position.x === goal.x && current_position.y === goal.y) {
                        clearInterval(interval);
                        alert("Reached the goal!");
                        document.getElementById('startButton').disabled = false;
                        document.getElementById('restartButton').disabled = false;
                    }
                } else {
                    clearInterval(interval);
                    alert("Path blocked, no valid path found!");
                    document.getElementById('startButton').disabled = false;
                    document.getElementById('restartButton').disabled = false;
                }
            }, 800);
        }

        // Handle the "Start" button click
        document.getElementById('startButton').addEventListener('click', () => {
            current_position = {x: 0, y: 0};
            path = [];
            startPathfinding();
            document.getElementById('startButton').disabled = true;
            document.getElementById('restartButton').disabled = true;
        });

        // Handle the "Stop" button click
        document.getElementById('stopButton').addEventListener('click', () => {
            stopInterval();
            document.getElementById('startButton').disabled = false;
            document.getElementById('restartButton').disabled = false;
        });

        // Handle the "Restart" button click
        document.getElementById('restartButton').addEventListener('click', () => {
            stopInterval();
            current_position = {x: 0, y: 0};
            path = [];
            staticObstacles = [];
            dynamicObstacles = [];
            drawGrid();
            document.getElementById('startButton').disabled = false;
        });

        // Clear all obstacles
        document.getElementById('clearObstacles').addEventListener('click', () => {
            staticObstacles = [];
            dynamicObstacles = [];
            drawGrid();
        });

        // Handle obstacle type change
        document.getElementById('obstacleType').addEventListener('change', (event) => {
            selectedObstacleType = event.target.value;
        });

        // Function to stop interval updates
        function stopInterval() {
            if (interval) {
                clearInterval(interval);
            }
        }

        // Initial grid draw
        drawGrid();
    </script>
</body>
</html>
