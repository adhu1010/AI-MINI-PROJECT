<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Path Finding Visualization with Moving Obstacles</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        #canvas {
            border: 1px solid black;
        }
        #controls {
            margin-top: 20px;
        }
        #controls button, #controls label {
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
        }
        #message {
            margin-top: 20px;
            font-size: 18px;
            font-weight: bold;
            color: green;
        }
    </style>
</head>
<body>
    <h1>Path Finding Visualization</h1>
    <canvas id="canvas" width="500" height="500"></canvas>

    <div id="controls">
        <button id="startButton">Start Path Finding</button>
        <button id="stopButton">Stop</button>
        <button id="restartButton">Restart</button>

        <div>
            <label for="obstacleType">Select Obstacle Type:</label>
            <select id="obstacleType">
                <option value="static">Static Obstacle</option>
                <option value="dynamic">Dynamic Obstacle</option>
            </select>
        </div>
        <button id="clearObstacles">Clear Obstacles</button>
    </div>

    <div id="message"></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 50;  // Size of each cell in pixels
        const rows = 10;
        const cols = 10;

        let staticObstacles = [];
        let dynamicObstacles = [];
        const start = { x: 0, y: 0 };
        const goal = { x: 9, y: 9 };
        let path = [];
        let current_position = { x: 0, y: 0 };
        let robotMovementInterval;
        let dynamicObstacleMovementInterval;
        let selectedObstacleType = 'static';
        let goalReached = false;

        // Draw the grid
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * gridSize;
                    const y = row * gridSize;

                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, gridSize, gridSize);

                    if (staticObstacles.some(obstacle => obstacle.x === col && obstacle.y === row)) {
                        ctx.fillStyle = 'gray';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    } else if (dynamicObstacles.some(obstacle => obstacle.x === col && obstacle.y === row)) {
                        ctx.fillStyle = 'black';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    } else if (start.x === col && start.y === row) {
                        ctx.fillStyle = 'green';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    } else if (goal.x === col && goal.y === row) {
                        ctx.fillStyle = 'red';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    } else if (path.some(step => step.x === col && step.y === row)) {
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    } else if (current_position.x === col && current_position.y === row) {
                        ctx.fillStyle = 'yellow';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    }
                }
            }
        }

        // Function to add obstacle by clicking on the grid
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const col = Math.floor(x / gridSize);
            const row = Math.floor(y / gridSize);

            if (selectedObstacleType === 'static') {
                const index = staticObstacles.findIndex(obstacle => obstacle.x === col && obstacle.y === row);
                if (index === -1 && !(col === start.x && row === start.y) && !(col === goal.x && row === goal.y)) {
                    staticObstacles.push({ x: col, y: row });
                } else {
                    staticObstacles.splice(index, 1);
                }
            } else if (selectedObstacleType === 'dynamic') {
                const index = dynamicObstacles.findIndex(obstacle => obstacle.x === col && obstacle.y === row);
                if (index === -1 && !(col === start.x && row === start.y) && !(col === goal.x && row === goal.y)) {
                    dynamicObstacles.push({ x: col, y: row });
                } else {
                    dynamicObstacles.splice(index, 1);
                }
            }

            drawGrid();
        });

        // Update selected obstacle type
        document.getElementById('obstacleType').addEventListener('change', (event) => {
            selectedObstacleType = event.target.value;
        });

        // A* pathfinding algorithm
        function getPath(start, goal, staticObstacles, dynamicObstacles) {
            const openSet = [start];
            const closedSet = new Set();
            const cameFrom = {};
            const gScore = {};
            const fScore = {};

            gScore[`${start.x},${start.y}`] = 0;
            fScore[`${start.x},${start.y}`] = heuristic(start, goal);

            while (openSet.length > 0) {
                const current = openSet.reduce((lowest, node) => {
                    return fScore[`${node.x},${node.y}`] < fScore[`${lowest.x},${lowest.y}`] ? node : lowest;
                });

                if (current.x === goal.x && current.y === goal.y) {
                    return reconstructPath(cameFrom, current);
                }

                openSet.splice(openSet.indexOf(current), 1);
                closedSet.add(`${current.x},${current.y}`);

                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    if (closedSet.has(`${neighbor.x},${neighbor.y}`) ||
                        staticObstacles.some(obstacle => obstacle.x === neighbor.x && obstacle.y === neighbor.y) ||
                        dynamicObstacles.some(obstacle => obstacle.x === neighbor.x && obstacle.y === neighbor.y)) {
                        continue;
                    }

                    const tentative_gScore = (gScore[`${current.x},${current.y}`] || Infinity) + 1;

                    if (!openSet.some(node => node.x === neighbor.x && neighbor.y === node.y)) {
                        openSet.push(neighbor);
                    } else if (tentative_gScore >= (gScore[`${neighbor.x},${neighbor.y}`] || Infinity)) {
                        continue;
                    }

                    cameFrom[`${neighbor.x},${neighbor.y}`] = current;
                    gScore[`${neighbor.x},${neighbor.y}`] = tentative_gScore;
                    fScore[`${neighbor.x},${neighbor.y}`] = gScore[`${neighbor.x},${neighbor.y}`] + heuristic(neighbor, goal);
                }
            }

            return [];
        }

        // Get the neighbors of a node
        function getNeighbors(node) {
            const neighbors = [];
            const directions = [
                { x: -1, y: 0 }, // up
                { x: 1, y: 0 },  // down
                { x: 0, y: -1 }, // left
                { x: 0, y: 1 }   // right
            ];

            for (const direction of directions) {
                const neighbor = { x: node.x + direction.x, y: node.y + direction.y };
                if (neighbor.x >= 0 && neighbor.x < cols && neighbor.y >= 0 && neighbor.y < rows) {
                    neighbors.push(neighbor);
                }
            }
            return neighbors;
        }

        // Heuristic function (Manhattan distance)
        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        // Reconstruct the path from the end node to the start node
        function reconstructPath(cameFrom, current) {
            const total_path = [current];
            while (cameFrom[`${current.x},${current.y}`]) {
                current = cameFrom[`${current.x},${current.y}`];
                total_path.push(current);
            }
            return total_path.reverse();
        }

        // Function to move dynamic obstacles
        function moveDynamicObstacles() {
            dynamicObstacles = dynamicObstacles.map(obstacle => {
                const possibleMoves = getNeighbors(obstacle).filter(neighbor => {
                    return !staticObstacles.some(obs => obs.x === neighbor.x && obs.y === neighbor.y) &&
                           !dynamicObstacles.some(obs => obs.x === neighbor.x && obs.y === neighbor.y) &&
                           !(neighbor.x === start.x && neighbor.y === start.y) &&
                           !(neighbor.x === goal.x && neighbor.y === goal.y);
                });

                if (possibleMoves.length > 0) {
                    return possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                }

                return obstacle; // Stay in place if no valid moves
            });

            drawGrid();
        }

        // Start the pathfinding process
        document.getElementById('startButton').addEventListener('click', () => {
            path = getPath(start, goal, staticObstacles, dynamicObstacles);
            if (path.length === 0) {
                alert("No path found!");
                return;
            }

            goalReached = false;
            current_position = { ...start };
            drawGrid();

            robotMovementInterval = setInterval(() => {
                if (goalReached) {
                    clearInterval(robotMovementInterval);
                    clearInterval(dynamicObstacleMovementInterval);
                    return;
                }

                if (path.length === 0) {
                    document.getElementById('message').innerText = "No path available! Recalculating...";
                    path = getPath(current_position, goal, staticObstacles, dynamicObstacles);
                } else {
                    const nextStep = path.shift();
                    
                    if (dynamicObstacles.some(obstacle => obstacle.x === nextStep.x && obstacle.y === nextStep.y)) {
                        document.getElementById('message').innerText = "Dynamic obstacle detected! Recalculating path...";
                        path = getPath(current_position, goal, staticObstacles, dynamicObstacles);
                        return;
                    }

                    current_position = nextStep;
                    drawGrid();

                    if (current_position.x === goal.x && current_position.y === goal.y) {
                        goalReached = true;
                        document.getElementById('message').innerText = "Goal Reached!";
                    }
                }
            }, 1000); // Move every second

            // Start moving dynamic obstacles
            dynamicObstacleMovementInterval = setInterval(() => {
                moveDynamicObstacles();
            }, 1500); // Move dynamic obstacles every 2 seconds
        });

        // Stop the movement
        document.getElementById('stopButton').addEventListener('click', () => {
            clearInterval(robotMovementInterval);
            clearInterval(dynamicObstacleMovementInterval);
        });

        // Restart the simulation
        document.getElementById('restartButton').addEventListener('click', () => {
            clearInterval(robotMovementInterval);
            clearInterval(dynamicObstacleMovementInterval);
            staticObstacles = [];
            dynamicObstacles = [];
            current_position = { ...start };
            path = [];
            goalReached = false;
            document.getElementById('message').innerText = "";
            drawGrid();
        });

        // Clear obstacles
        document.getElementById('clearObstacles').addEventListener('click', () => {
            staticObstacles = [];
            dynamicObstacles = [];
            drawGrid();
        });

        drawGrid();
    </script>
</body>
</html>
